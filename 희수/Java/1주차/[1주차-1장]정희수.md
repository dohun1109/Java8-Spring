**CHAPTER 1**

**자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?**

- 자바가 거듭 변화하는 이유
- 컴퓨팅 환경의 변화
- 자바에 부여되는 시대적 변화 요구
- 자바 8과 자바 9의 새로운 핵심 기능 소개

## 역사의 흐름

- JAVA 8 : 자바 역사를 통틀어 가장 큰 변화 (간결한 코드, 멀티코어 프로세서의 쉬운 활용)

    <aside>
    💡 멀티코어 CPU 대충화와 같은 하드웨어적인 변화도 자바 8에 영향을 미침.

    - 지금까지의 대부분 자바 프로그램은 코어 중 하나만을 사용
    - 자바 8이 등장하기 전에는 나머지 코어를 활용하려면 스레드를 사용하는 것이 대중적 방법이지만,
        - 스레드를 사용하면 관리하기 어렵고 많은 문제가 발생할 수 있다는 단점

  —> 이런 병렬 실행 환경을 쉽게 관리하고 에러가 덜 발생하는 방향으로 진화

    </aside>

  JAVA 8에서 제공하는 새로운 기술 (함수형 프로그래밍 기법에서 굿ㅅ)

    - 스트림 API (병렬 연산 지원)
    - 메서드에 코드를 전달하는 기법 (다른 자료구조로 전달도 가능, 동작 파라미터화 구현)
    - 인터페이스의 디폴트 메소드


- JAVA 9 : 중요한 변화가 있었지만 8만큼 획기적이거나 생산성이 바뀌진 않음

  ‘리액터브 프로그래밍’ 이라는 병렬 실행 기법을 지원.


JAVA 10 : 형 추론과 관련해 약간의 변화

```java
Collections, sort(inventory, new Comparator<Apple>() {
	public int compare(Apple al, Apple a2) {
		return al.getWeight().compareTo(a2.getWeight());
	}
});
```

```java
inventory.sort(comparing(Apple::getWeight));
```

### 자바의 출발

- 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향언어로 시작.
- 처음부터 스레드와 락을 이용한 소소한 동시성 지원 (자바의 하드웨어 중립적인 메모리 모델 때문에 멀티코어 프로세서에서 병렬적으로 수행되는 스레드는 싱글코어에서의 동작과 달리 예기치 못한 상황을 일으킬 수 있음.)
- 코드를 JVM 바이트 코드로 컴파일하는 특징(모든 브라우저에서 가상 머신 코드를 지원) 때문에 인터넷 애플릿 프로그램의 주요 언어가 됨.

### 대중적인 프로그래밍 언어로 성장

- 객체지향은 1990년대 두 가지 이유로 각광받음 (결국 ‘모든 것은 객체다’)
    1. 캡슐화 덕분에 C에 비해 소프트웨어 엔지니어링적인 문제가 훨씬 적다는 점
    2. 객체지향의 정신적인 모델 덕분에 윈도우 95 및 그 이후의 WIMP 프로그래밍 모델에 쉽게 대응할 수 있다는 점

### 변화의 바람

- 빅데이터라는 도전에 직면하면서 멀티코어 컴퓨터나 컴퓨팅 클러스터를 이용해서 빅데이터를 효과적으로 처리할 필요성이 커짐

  —> 병렬 프로세싱을 활용해야 하는데 지금까지의 자바로는 충분히 대응할 수 없었음.

    <aside>
    👉🏻 따라서 JAVA 8은 더 다양한 프로그래밍 도구 그리고 다양한 프로그래밍 문제를 더 빠르고 정확하며 쉽게 유지보수 할 수 있다는 장점을 제공.

    </aside>


## 스트림 처리 (Stream processing)

### 스트림 (Stream)

: 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임.

- 이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어들이며, 출력 스트림으로 데이터를 한 개씩 기록한다.
- 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있음
- 스트림 패키지에 정의된 Stream<T> : T 형식으로 구성된 일련의 항목(Streams의 S 는 대문자)
- 스트림 API는 조립라인처럼 어떤 항목을 연속으로 제공하는 어떤 기능이라고 생각하면 됨
- 파이프 라인을 만드는 데 필요한 많은 메서드 제공

### !!! 핵심

- 기존에는 한 번에 한 항목을 처리했지만 JAVA 8에서는 우리가 하려는 작업을 (데이터베이스 질의처럼) 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것.
- 또  스트림 파이프라인을 이용해서 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다는 부가적인 이득.
- 스레드라는 복잡한 작업을 사용하지 않으면서도 공짜로 병렬성 얻을 수 있음.

## 동작 파라미터화로 메서드에 코드 전달

(behavior parameterization)

JAVA 8에 추가된 두 번째 프로그램 개념은 코드 일부를 API로 전달하는 기능.

동작 파라미터화 : 메서드(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능

- 동작 파라미터화가 왜 중요?

  —> 스트림 API는 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초함.


## 병렬성과 공유 가변 데이터

세 번째 프로그래밍의 개념은 ‘병렬성은 공짜로 얻을 수 있다’ 는 말에서 시작됨.

- 병렬성을 얻는 대신 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 함.
- 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 함.
    - 그럴려면 공유된 가변 데이터 (shared mutable data)에 접근하지 않아야 한다.
        - 이런 함수를 ‘순수 함수’, ‘부작용 없는 함수’, ‘상태 없는 함수’ 라고 부름
- 지금까지는 독립적으로 실행될 수 있는 다중 코드 사본과 관련된 병렬성을 고려함.
    - 하지만 공유된 변수나 객체가 있으면 병렬성에 문제가 발생
        - ex) 두 프로세스가 공유된 변수를 동시에 바꾸려 하면?
            - 기존처럼 synchronized 이용해서 공유된 가변 데이터를 보호하는 규칙을 만들 수 있지만(일반적으로 synchronized는 시스템에 악영향) JAVA 8 스트림을 이용하면 기존의 자바 스레드 API보다 쉽게 병렬성 활용 가능.
            - 다중 프로세싱 코어에서는 synchronized 사용하면 코드가 순차적으로 실행되어야 하므로 병렬이라는 목적을 무력화 시키면서 쨌든 별로임

공유되지 않은 가변 데이터, 메서드, 함수 코드를 다른 메서드로 전달하는 두 가지 기능은 **함수형 프로그래밍** 패러다임의 핵심적인 사항.

### 자바가 진화해야 하는 이유

—> 하드웨어나 프로그래머 기대에 부응하는 방향으로 변화해야 함.

- 틀에 박힌 Iterator 대신 for-each 루프를 사용할 수 있게 됨.
    - 기존 값을 변화시키는 데 집중했던 고전적인 객체지향에서 벗어나 함수형 프로그래밍으로 다가섬.
    - 함수형 프로그래밍 : 우리가 하려는 작업이 최우선시되며 그 작업을 어떻게 수행하는지는 별개의 문제로 취급.
- 전통적인 객체지향 프로그램과 함수형 프로그래밍은 완전 상극

  BUT, 자바 8에서 함수형 프로그래밍을 도입함으로써 두 가지 프로그래밍 패러다임의 장점을 모두 활용 가능.


## 자바 함수

함수(function) : 메서드(method), 특히 정적 메서드(static method)와 같은 의미로 사용됨.

JAVA 의 함수 : 여기에 더해서 수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수.

- 자바 8에서는 멀티코어에서 병렬 프로그래밍을 활용할 수 있는 스트림과 연계돨 수 았도록 함수를 추가.
    - 자바에서 프로그램이 조작할 수 있는 값 :

        1. 10(int 형식), 3.14(double 형식) 등의 기본 값

        1. 객체(객체의 참조도 값이긴 함)도 값임.
            - 객체 참조는 클래스의 인스턴스를 가리킴.
                - “abc”, new Integer(1111), new HashMap<Integer, String> (100)등으로 객체 참조 얻기 가능.
    - 그런데 왜 함수 필요?

      —> 프로그래밍 언어의 핵심은 값을 바꾸는 것. (first-class 또는 citizen 이라고 부름)

        - 프로그램을 실행하는 동안 모든 구조체(메서드, 클래스 같은)를 자유롭게 전달할 수는 없다.
        - 인스턴스화한 결과가 값으로 귀결되는 클래스를 정의할 때 메서드를 아주 유용하게 활용할 수 있음.

      —> 자바 8에서 메서드를 값으로 취급할 수 있게 기능 추가.

- **메소드 참조(method reference)**
    - 디렉토리에서 모든 숨겨진 파일을 필터링하는 기존 방법.

    ```java
    File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
    	public boolean accept(File file) {
    		retern file.isHidden();
    	}
    });
    ```

    - JAVA 8에서 방법

    ```java
    File[] hiddenFiles = new File(".").listFiles(File::isHidden);
    ```


### 람다 : 익명 함수

`(int x) → x + 1`

- named 메서드를 퍼스트클래스로 취급할 뿐만 아니라 람다(또는 익명 함수)를 포함하여 함수도 값으로 취급이 가능.
- 클래스를 만든 다음에 클래스 내부에 add1 이라는 메서드를 정의해서 Utils::add1을 만들수 있는데 왜 필요함?
    - 직접 메서드를 정의할 수도 있지만, 이용할 수 있는 편리한 클래스나 메서드가 없을 때 더 간결하게 코드 구현 가능.
- 메서드 전달에서 람다로,

```java
filterApples(inventory, (Apple a) → GREEN.equals(a.getColor()) ) ;

filterApples(inventory, (Apple a) → a.getWeight() > 150 ) ;

filterApples(inventory, (Apple a) → a.getWeight() < 80 || RED.equals(a.getColor()) ) ;
```